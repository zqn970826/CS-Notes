[TOC]

# 数据链路层

# 网络层

## IPv4

### IP 数据报格式

![image-20200419165904339](/Users/skye/Desktop/%E6%80%BB%E7%BB%93/20200422013726.png)

- **ipv4数据报首部长度默认为20B**，因为后面21B~60B是可选+填充。不是4B的整数倍，要填充。

- **首部长度的基本单位为4B**，**总长度的基本单位是1B**，**片偏移的基本单位是8B**。

- 版本 : 有 4（IPv4）和 6（IPv6）两个值；

- 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。

- 区分服务 : 用来获得更好的服务，一般情况下不使用。

- 总长度 : 包括首部长度和数据部分长度。

- 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。

- 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。

- 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。

- 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符，只有前两位有意义MF & DF。

    - MF (More Fragment): MF = 1, 后面还有分片。合并时要将首部的20B删掉。除了最后一片，其他MF均为1;
    - DF (Don’t Fragment): DF = 1, 不能分片。过大则丢弃。

- 片偏移 : 和标识符一起，用于发生分片的情况。**片偏移的基本单位为 8 字节**

    - IP数据报分片

### IPv4地址分类

#### 网络号+主机号

![image-20200419184353377](/Users/skye/Desktop/%E6%80%BB%E7%BB%93/20200422013733.png)

- 由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。
- IP 地址 ::= {< 网络号 >, < 主机号 >}
- 分类：
    - A类地址：1~126.
    - B类地址：128.1 ~ 191.255
    - C类地址：192.0.1 ~ 223.255.255

##### 6类特殊地址：

- 直接广播地址：主机号全为1， 目的地址
- 受限广播地址：255.255.255.255，目的地址(只可查找该网络下的所有主机)
- 环回地址：127.0.0.1，源地址或目的地址
- 特定主机：网络号全0，主机号特定
- 这个网络上的主机：全0，表示源地址或**默认目的地址**
- 网络地址：网络号特定，主机号全0

##### NAT

* Network Address Translation

- 专用地址
    - 10.0.0.0 ~ 10.255.255.255
    - 172.16.0.0 ~ 172.31.255.255
    - 192.168.0.0 ~ 192.168.255.255
- NAT技术：**将专用网内部使用的本地IP地址转换成有效的外部全球IP地址**，使得整个专用网只需要一个全球IP地址就可以与因特网通信；
- NAT协议就是利用**端口域**来解决内网到外网的地址映射问题；
- **NAT转换表实现数据报的转发**；
- 作用
    - 减缓了IPv4地址枯竭；
    - 能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机；

#### 网络号+子网号+主机号

- 通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。
- IP 地址 ::= {< 网络号 >, < 子网号 >, < 主机号 >}要使用子网，必须配置子网掩码。
    - 子网掩码是为了获取网络号
- 主机号全为0/ 1，不能用。

##### 子网掩码和默认网关是什么及作用？

###### 子网掩码

* 是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。
* 子网掩码只有一个作用，就是将某个IP地址划分成**网络地址**和**主机地址**两部分。

###### 默认网关

* 默认网关是一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。现在主机使用的网关，一般指的是默认网关。
* 一个网络通向其他网络的IP地址，实现这两个网络之间的通信，则必须通过网关。

#### 无分类编制 CIDR

- 无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。
- IP 地址 ::= {< 网络前缀号 >, < 主机号 >}
- CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。
- CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。
- 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为构成超网 。
- 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用**最长前缀匹配**来确定应该匹配哪一个，越长越具体。

#### 分类总结

| 研究对象             | 主要表项                           |
| :------------------- | ---------------------------------- |
| 没划分子网前的路由表 | 目的网络地址、下一跳地址           |
| 划分子网后的路由表   | 目的网络地址、子网掩码、下一跳地址 |
| 使用CIDR后的路由表   | 网络前缀、下一跳地址               |

1. 划分子网后的路由表
    1. 从收到的分组首部提取目的IP地址D。
    2. 先判断是否为直接交付，用那些和路由器直接相邻的网络的子网掩码和D逐位相与，看是否和相应的网络地址匹配。匹配就直接交付，不匹配就间接交付。
    3. 若路由表中有目的地址为D的特定路由主机，则将分组传送给指明的下一跳路由主机。转4
    4. 对路由表中的每一行的子网掩码和D逐位与。若结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器。转5
    5. 若路由表中有一个默认路由，将分组转发给默认路由。转6
    6. 报告转发分组错误；
2. 使用CIDR后的路由表
    - 查找路由表时会得到不止一个匹配结果，选择最长前缀匹配。（找地址最准确的那个）

## 地址解析协议 ARP

* Address Resolution Protocol

### 介绍

1. 网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，**IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变**。
2. ARP 用于解决在**同一局域网内**的主机或路由器的 IP地址和 MAC地址映射问题。
3. 每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。
4. 具体说来就是将网络层（IP层，也就是相当于OSI的第三层）地址解析为数据连接层（MAC层，也就是相当于OSI的第二层）的MAC地址。

### 解析过程

#### 主机间在同一个网段

1. 主机A首先查看自己的ARP表，确定其中是否包含有主机B对应的ARP表项。如果找到了对应的MAC地址，则主机A直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B。
2. 如果主机A在ARP表中找不到对应的MAC地址，则**缓存该数据报文**，然后以广播方式发送一个ARP请求报文。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的IP地址和MAC地址，目标IP地址和目标MAC地址为主机B的IP地址和全0的MAC地址。由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求，但只有被请求的主机（即主机B）会对该请求进行处理。
3. 主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中。之后**以单播方式**发送ARP响应报文给主机A，其中包含了自己的MAC地址。
4. 主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去。

#### 主机间不在同一网段时

* **有几个路由器， +1为使用ARP协议次数**

1. 主机A就会先向网关发出ARP请求，ARP请求报文中的目标IP地址为网关的IP地址。
2. 当主机A从收到的响应报文中获得网关的MAC地址后，将报文封装并发给网关。如果网关没有主机B的ARP表项，网关会广播ARP请求，目标IP地址为主机B的IP地址，当网关从收到的响应报文中获得主机B的MAC地址后，就可以将报文发给主机B；如果网关已经有主机B的ARP表项，网关直接把报文发给主机B。

## 网际控制报文协议 ICMP

* Internet Control Message Protocol

* 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。

### ICMP 报文种类

#### ICMP 差错报告报文

- 终点不可达：无法交付数据报。
- 源点抑制(Source quench)：拥塞。
- 时间超过：
    - 1. TTL减为0，丢弃报文并向源点发送时间超过报文；
          2. 当终点在规定时间内不能收到一个数据报的全部分片时，丢弃所有，并向源点发送一个时间超过报文；
- 参数问题 ：当收到的数据报首部中有字段不对
- 改变路由（重定向）(Redirect)：让主机知道把数据报发送给比当前更好的路由。

#### ICMP 询问报文

- 回送请求和回答报文
- 时间戳请求和回答报文

格式

- ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。

##### 应用

###### Ping（应用层）

- 用来测试两台主机之间的连通性。
- Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。

###### Traceroute（网络层）

- 用来跟踪一个分组从源点到终点的路径。
- Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。
- 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；
- 接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。
- 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。
    源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。

## IPv6

### 简介

1. IPv4：32位，IPv6：128位
2. 扩展的地址层次结构
3. IPv6的首部长度必须是8B的整数倍
4. 简化了IP分组的首部
5. IPv6更好的支持选项

### IPv4 与 IPv6互通

#### 双协议栈

双协议栈技术就是指在一台设备上同时启用IPv4协议栈和IPv6协议栈。这样的话，这台设备既能和IPv4网络通信，又能和IPv6网络通信。如果这台设备是一个路由器，那么这台路由器的不同接口上，分别配置了IPv4地址和IPv6地址，并很可能分别连接了IPv4网络和IPv6网络。如果这台设备是一个计算机，那么它将同时拥有IPv4地址和IPv6地址，并具备同时处理这两个协议地址的功能。

#### 隧道技术

使用隧道传递的数据（或负载）可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包**重新封装**然后通过隧道发送。新的帧头提供路由信息，以便通过互联网传递被封装的负载数据。

* 会丢失信息

## 路由算法

### 分类

#### 静态路由选择策略

* 非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。

#### 动态路由选择策略

* 自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。

1. 距离-向量路由算法 Distance-Vector
    - 所有节点都定期地将他们整个路由选择表传送给所有与之直接相邻的节点。
    - RIP算法
2. 链路状态路由算法 Line-Status
    - 要求参与该算法的节点都有完全的网络拓扑信息。
        1. 主动测试所有邻接节点的状态。
        2. 定期的将链路状态传播给其他所有节点。
    - 三大特性
        1. **向本自治系统中所有路由器发送信息**。
        2. 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器知道的部分信息。
        3. **只有当链路状态发生改变时**，路由器采用洪泛法向所有路由器发送信息。
    - OSPF算法

##### 比较

1. LS比 DV报文更加复杂
2. LS比 DV收敛快
3. LS比 DV更具健壮性

### 层次路由

- 自治系统 AS (Autonomous System):在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。

## 路由协议

### 协议分类

#### 内部网关协议 IGP

* Interior Gateway Protocol

- 在一个自治系统内部使用的路由选择协议。
- RIP、OSPF

##### RIP

1. RIP 是一种基于距离-向量的路由选择协议，**使用UDP发送通告**。

2. 距离-向量算法

    1. 距离是指跳数，直接相连的路由器跳数为 1。**跳数最多为 15，超过 15 表示不可达。**

    2. 三要点

        1. 仅和相邻路由器交换信息。
        2. 交换的信息是当前本路由器所知道的全部信息，即自己的路由表。
        3. RIP 按固定的时间间隔交换陆游信息。

    3. 算法简介

        1. 相邻路由器 X发来的 RIP报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；

        2. 对修改后的 RIP 报文中的每一个项目，进行以下步骤：

            ```c
            if (项目中的目的网络不在路由表中) {
              加入路由表中；
            }
            else if (下一跳字段中给出的路由器地址相同) {
              把收到的项目替换原路由表中的项目；
            }
            else if (收到项目中的距离小于路由表中的距离) {
              更新；
            }
            else {
              nothing；
            }
            ```

        3. 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。若其后120s内仍未收到更新包文，就将这些路由从路由表中删除。

    4. 特点

        - RIP 协议实现简单，开销小，收敛过程较快。
        - 但是 RIP 能使用的最大距离为 15，限制了网络的规模。
        - 交换的信息是完整的路由表，随着网络规模的扩大，开销也会增大。
        - 并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。

##### OSPF

1. 开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的，**使用IP传输**。
    - 开放表示 OSPF不受某一家厂商控制，而是公开发表的；
    - 最短路径优先表示使用了 Dijkstra提出的最短路径算法 SPF。
2. 特点：
    - 仅在网络拓扑发送变化时，才会向本自治系统中的所有路由器发送信息，这种方法是洪泛法。
    - 发送的信息就是与相邻路由器的链路状态（链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示）。
    - 相邻路由器会根据此信息修改自己的路由表，并将其发送给自己的相邻路由器。
    - OSPF比 RIP收敛快
    - 所有路由器都具有一模一样的网络拓扑结构。
    - 虽然用最短路径可以算出最优路径，但在路由表中只会存储“下一跳”。
    - OSPF路由表中表示目的网络的参数为费用（代价）。

#### 外部网关协议 EGP

* External Gateway Protocol

- 若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。
- BGP-4

##### BGP

1. 通过TCP交换报文，通告一个前缀时，也包括BGP属性；
2. 若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。
    - AS 之间的路由选择很困难，主要是由于：
        - 互联网规模很大；
        - 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；
        - AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。
    - BGP 只能寻找一条比较好的路由，而不是最佳路由。
3. 基本原理
    - 每个 AS 都必须配置 至少一个BGP发言人（路由器）；
    - 通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息；
    - 在此连接上交换BGP报文以建立BGP绘画，再利用BGP会话交换路由信息。
    - 交换信息后，即可选择较好的路径。
4. 特点
    - BGP交换路由信息的节点数量级是自治系统数的量级，比自治系统中的网络数少了很多。
    - BGP发言人很少，找起来简单。
    - 支持CIDR。
    - 只需要更新有变化的部分，开销小。

## 路由器

### 组成

路由器由RAM、ROM、FLASH和NVRAM这4部分组成。

* RAM (Random Access Memory)：随机访问存储器。RAM中运行着Cisco IOS的镜像文件以及running-config文件。
* ROM (Read Only Memory)：只读内存。ROM中保存着最基本功能的代码（最小的IOS代码），它用于引导路由器。
* FLASH：闪存。FLASH中容纳了IOS软件的镜像。
* NVRAM：非易失性随机访问存储器。NVRAM用来存储startup-config文件。当切断电源时，NVRAM用一个电池来维护其中的数据。

IOS（路由器操作系统）

配置文件：运行配置文件（Running-Configuration） 启动配置文件（Startup-Configuration）

### 结构

输入端口、交换结构、输出结构、选路处理器；

经内存交换，经过一根总线交换，经过一个互联网络交换。

**分组延迟和丢失可能发生在路由器的什么地方？**

* 输入端口和输出端口：溢出/ 处理不及时；

### 功能

#### 路由选择

* 由路由算法去认定一个进来的分组应该被传送到哪一条输出线路上；
* 路由算法负责填充和更新路由表；

#### 分组转发

* 当一个分组到达时，在路由表中查找分组所对应的输出线路，将分组转发至正确的线路上去；
* 转发就是路由器根据**转发表**将用户的IP数据报从合适的端口转发出去；
* **路由表时根据路由选择算法得出，而转发表是从路由表得出**。



# 传输层

## UDP 和 TCP 的特点

- 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。主要用于即时强的场合如:视频聊天，语音电话等。
- 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一），可用于可靠要求高的场合如:SMTP、FTP、HTTP等。

## UDP

### 首部格式

![image-20200417175904188](/Users/skye/Desktop/%E6%80%BB%E7%BB%93/20200422011720-20200505174757944.png)

###  UDP效验

- 伪首部（从数据报所在IP分组头的分组头中提取）只用于计算和验证校验和，不传送。
- 计算校验和前要加上伪首部。
- 若计算时数据长度不为偶数需要填充0

## TCP

### 首部格式

![image-20200417182309068](/Users/skye/Desktop/%E6%80%BB%E7%BB%93/20200422012454.png)

- 序号 seq：占4B，用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。
- 确认号 ack：占4B，表示**期望收到的下一个TCP报文段的第一个字节序号**。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节（501~700），因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
- **数据偏移（首部长度）**：占4位，指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。**最小单位4B， 最长为15（1111~0001）\* 4B**
- 保留字段：占6位，今后使用。
- 紧急URG：URG=1，表明有紧急数据，需要尽快传送，需要与紧急指针配合使用。**不进入缓冲！**
- 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
- 推送比特PSH：PSH=1，尽快交付应用程序，不需要等缓冲满，再向上交付。
- 复位RST：RST=1，出现了严重差错，必须释放连接，再重新建立。
- 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
- 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。
- 窗口字段 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。
- 校验和字段：检验首部和数据两部分。检验前要加上12B的伪首部（与UDP类似，但将17改为6）。
- 紧急指针字段：2B
- 选项字段：长度可变。
- 填充字段：为了使整个首部长度为4B的整数倍。

### 连接管理

- 三阶段：连接建立、数据传输、连接释放。
- TCP 连接的端点叫做套接字(socket)或插口。
    - 套接字 socket = (IP地址: 端口号)

#### 三次握手（建立连接）

![image-20200417214051463](/Users/skye/Desktop/%E6%80%BB%E7%BB%93/20200422012513.png)

1. 假设 A 为客户端，B 为服务器端。 B 处于 LISTEN（监听）状态，等待客户的连接请求。
2. A 向 B 发送连接请求报文，SYN = 1，选择一个初始的序号 seq = x, 表明传送数据时的第一个数据字节是序号x，并进入SYN_SENT状态，等待服务器确认。
3. B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，ack = x+1，同时也选择一个初始的序号 seq = y，此时服务器进入SYN_RECV状态。
4. A 收到 B 的连接确认报文后，还要向 B 发出确认 ACK = 1，ack = y+1，seq = x+1。
5. B 收到 A 的确认后，连接建立，客户端和服务器进入ESTABLISHED（TCP连接成功）状态。

##### **为啥在建立连接时不能每次选择相同的、固定的初始序号？**

1. 假定A和B**频繁建立连接**，传送一些数据后，释放连接。
2. 假定每一次建立连接，A主机都选择相同的、固定的初试序号。
3. 假定主机 A发送的某些 TCP在网络中滞留了较长时间，以致造成主机A超时重传这些报文。
4. 假定有一些报文在重传之前到达主机 B，此时传送该报文的连接已经释放，到达时已经是一条新的 TCP连接。
5. 这样主机 B可能会接收到过时的、没有意义的报文段，从而导致错误。

- 所以，必须是迟到的 TCP报文段的序号不处在新的连接所使用的的序号范围之内。

##### **为啥不用“两次握手”建立连接？**

- **“三次握手”完成了两个重要功能**：
    1. **双方做好发送数据的准备**
    2. **允许双方就初始序列号进行协商，在握手过程中被发送和确认。**
- 若改成“两次握手”，则**有可能发送死锁**。A给B发送了一个连接请求分组，B收到了分组，并发送了确认应达分组。由于采用“两次握手”协议， B认为连接已经成功建立，并开始发送数据。此时，若B的应达分组在传输中丢失，A不知道B是否已经准备好，且不知道B发送数据的初始序列号，将忽略 B发送的数据。A甚至怀疑B是否收到自己的连接请求分组。在这种情况下，A重发连接请求分组，且只等待 B的连接确认应达分组；B重发数据分组。形成了死锁。

#### 四次挥手（断开连接）

![image-20200417220259307](/Users/skye/Desktop/%E6%80%BB%E7%BB%93/20200422012519.png)

1. A发送连接释放报文，FIN=1，seq = u，此时 A停发数据。
2. B收到之后发出确认，ACK = 1, ack = u+1, seq = v，B通知高层，此时TCP属于半关闭状态，B能向 A发送数据，但是A不能向B发送数据。
3. 当 B不再需要向 A发送数据时，发送连接释放报文，FIN=1，ACK = 1, ack = u+1， seq = w。
4. A收到后发出确认 ACK = 1，seq = u+1，ack= w+1，进入 TIME-WAIT状态，等待 2 MSL（最大报文存活时间）后释放连接。
5. B收到 A的确认后释放连接。

##### **为啥要“四次挥手”？**

- 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

##### **为啥要“TIME_WAIT = 2MSL”？**

1. 为了保证A发送的最后一个确认报文能够到达B
    * 如果A不等待2MSL，A返回的最后确认报文段丢失，则 B不能进入正常关闭状态，而 A此时已经关闭，也不可能再重传。
2. 防止出现“已失效的连接请求报文段”**。 A在发送完最后一个确认报文段后，再经过 2MSL可保证本连接持续的时间内所产生的的所有报文段从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。情况与“两次握手”相同。

### 可靠传输

#### 数据编号与确认

- 采用累积确认。
- ACK = 1, seq = x, ack = ?
- ACK = 1, ack = x+1**（表示期待收到第x+1个序号）**, seq = ?
- 另外，TCP通过数据分段中的序列号来保证所有传输的数据可以按照正常的顺序进行重组，__从而保障数据传输的完整__。

#### 重传机制

- 每发送一个报文，就对改报文进行计时。到了重传时间，就开始重传。
- 采用自适应算法来计算超时计时器的重传时间。
    - RTO（超时重传时间）略大于RTT

### 流量控制 & 拥塞控制

#### 流量控制 Flow Control

* 为了控制发送方发送速率，保证接收方来得及接收。

* 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

##### 滑动窗口

- 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。
- TCP为每一个连接设有一个持续计时器。只要TCP连接的一方收到对方的零窗口，就启动持续计时器。若持续计时器设置的时间到期了，就发送一个零窗口探测报文段（仅携带1B数据），对方在确认这个探测报文段是给出了现在的窗口值，若为0，继续重设持续计时器，不为0，就打破了死锁的僵局。
- 可用不同的机制来控制TCP报文段的发送时机。
    1. TCP维持一个变量，它等于最大报文长度（MSS）。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。
    2. 由发送方的应用进程指明要求发送报文段，即TCP支持的推送（push）操作。
    3. 发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但不能超过MSS）发送出去。

#### 拥塞控制 Congestion Control

**防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载**。

拥塞控制所要做的都有一个前提：**网络能够承受现有的网络负荷**。拥塞控制是一个**全局性**的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。

* 开环控制：一开始就考虑所有因素；
* 闭环控制：反馈调整；

##### 四大算法

接收端窗口rwnd：接收端根据其目前接受缓存大小所确定的最新的窗口值，反映接收端容量。

拥塞窗口cwnd：发送端根据自己估计的网络拥塞程度设置的窗口值，反映了网络的当前容量。

发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：__拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。__

__发送端发送窗口的上限值应当取 cwnd和 rwnd的 MIN__；

默认接收端缓存无限制，则cwnd ≈ 发送端窗口大小；

* 慢开始
* 拥塞避免
* 快重传
* 快恢复

![](/Users/skye/Desktop/%E6%80%BB%E7%BB%93/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39313066363133662d353134662d343533342d383764642d3962343639396435396433312e706e67.png)

###### 慢开始与拥塞避免

发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现了超时，则令 ssthresh = cwnd / 2（乘法减小），然后重新执行慢开始。

__乘法减小：无论慢开始还是拥塞避免，只要出现了一次超时，就进行乘法减小，目的是迅速减少主机发送到网络中的分组数，是的发送拥塞的路由器有足够时间把队列中挤压的分组处理完毕__；

加法增大：执行拥塞避免算法时，收到对所有报文的确认后，就将cwnd++，防止网络过早出现拥塞；

同时拥塞避免不能完全避免拥塞，使网络不容易出现拥塞；

###### 快重传与快恢复

![快重传](/Users/skye/Desktop/%E6%80%BB%E7%BB%93/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66363162353431392d633934612d346466312d386434642d6165643961653863633664352e706e67.png)

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

在这种情况下，只是丢失个别报文段，很可能不是发生网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为新的 ssthresh。

## TCP/IP网络协议的核心是什么，怎么理解 "over everything"和 "everything over"

* TCP/IP协议的核心是TCP、UDP和 IP协议 

* 分层次画出具体的协议来表示TCP/IP协议族，它的特点是上下两头大而中间小：应用层和网络接口都有很多协议，而中间的IP层很小，上层的各种协议都向下汇聚到一个IP协议中。这种很像沙漏计时器形状的TCP/IP协议族表明
    * TCP/IP协议可以为各种各样的应用提供服务（everything over ip）
    * TCP/IP协议也允许 IP协议在各种各样的网络构成的互联网上运行 (IP over everything)。

# 应用层

## C/S 模型 & P2P模型

* C/S 模型 = Client/ Sever模型；
* P2P 模型 = Peer 2 Peer模型：（对等网络）
    * P2P就是人可以直接连接到其他用户的计算机、交换文件，而不是像过去那样连接到服务器去浏览与下载。
    * P2P应用程序应该包括三个阶段：发现，连接和通信。首先必须发现对方，发现阶段负责动态定位对等节点的网络位置；连接阶段负责在对等节点之间建立网络连接；而通信阶段负责在对等节点之间传输数据。 

## FTP的PORT（主动模式）和PASV（被动模式）区别

![img](/Users/skye/Desktop/%E6%80%BB%E7%BB%93/204156_vG81_97118.jpg)

![204218_G2gD_97118.jpg](/Users/skye/Desktop/%E6%80%BB%E7%BB%93/204218_G2gD_97118-20200503173315872.jpg)
